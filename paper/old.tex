%% \subsection{Problem Characterization}

%% One important step in search-based optimization is to characterize a
%% candidate solution to the target problem. Candidate solutions are the
%% objects that the search optimize towards solutions. In this case, a 
%% candidate solution is an encoding of a Suricata rule.  \tname\ encodes
%% the rule options segment of a Suricata rule (see
%% Section~\ref{sec:example-suricata-rules}) as a vector of Option
%% objects. Some options are discarded as they only serve for
%% documentation. For example, the options \CodeIn{msg},
%% \CodeIn{classtype}, and \CodeIn{misc-activity}, appearing in the
%% example on Figure~\ref{fig:synflood-example}, have no influence in
%% triggering the actions associated with the rule. The option
%% \CodeIn{flags}, however, is relevant to trigger the action. \tname{}
%% models that option with a data structure storing two fields, one of
%% character type and another of integer type. This enables \tname{} to
%% mutate each element separately. Similar encodings are used in modeling
%% the other relevant options. We found what options are (ir)relevant by
%% inspecting Suricata code for the presence of \CodeIn{eval} functions,
%% which are invoked from a main loop to process each action rule. The
%% presence of such a function for a given option indicates that it is
%% relevant for triggering some action of some rule.

%% \subsection{Initial State}

%% To bootstrap the search, \tname{} needs to select an initial
%% solution. When creating such candidate solution, \tname{} first looks
%% for the protocol related to the malicious input traffic. Then, it
%% selects the relevant options for that protocol and initializes the
%% option vector with default values. \Mar{Suricata define valores
%%   default?  Vcs. definiram?  Isto foi baseado em popularidade ou o
%%   que?}

%% %% \tname{}
%% %% uses an abstract representation of a Suricata rule that reflects the
%% %% concrete representation of the rule. The concrete rule representation
%% %% is the one actually used by Suricata whereas the abstract
%% %% representation is the one \tname{} uses to run the search.

%% \subsection{Fitness Functions}

%% The fitness value of a candidate solution $c$, modeling the rule
%% options $o_1, \dots, o_n$ is given by $f(c)=1-\Sigma{d(o_i,m)}/n$,
%% where $i$ ranges from 1 to $n$ and $m$ denotes the negative
%% traffic. The higher the fitness value the better, \ie{}, the fitter
%% the candidate solution $c$ will be.  The value of the expression
%% $d(o_i,m)$, associated with option $o_i$, ranges over
%% 0-1. Consequently, the value of the expression $\Sigma{d(o_i,m)}/n$
%% itself is in the 0-1 range, as there are $n$ options, and the range of
%% the function is 0-1.

%% As usual, we used customized distance functions to compute $d(o_i,
%% m)$. For example, let us consider the \CodeIn{flags} option, discussed
%% on Figure~\ref{fig:synflood-example}. Recall that this option
%% identifies the SYN packet in the tcp protocol and that its encoding in
%% \tname{} stores two attributes---one categorical and one
%% numerical. The value of $d(o_i, m)$, in this case, is obtained by
%% computing the normalized Euclidean distance in the two-dimensional
%% space. Considering that each of the two dimensions has cardinality of
%% ten, the distance of a candidate solution holding the option
%% \CodeIn{flags(S,13)} to the solution will be 0.22
%% (=$1/\sqrt{20}$). Note that the smaller the distance the better.

%% \tname{} uses a modified version of Suricata to measure distance. It
%% updates the rule set that the modified version of Suricata analyses,
%% injects the traffic on the network, and monitors the execution. Each
%% rule option has an associated \CodeIn{eval} function in code. \tname{}
%% monitors the execution of these functions to identify how far it is
%% from returning true, which indicates it is closer to trigger the
%% action associated with the rule. 
%% \Luc{Originalmente, o suricata interrompe a checagem de uma regra quando alguma das opções não dá match com o pacote analisado. O código fonte foi alterado para que as regras sempre tenham todas as suas opções verificadas. A função de verificação de uma opção retorna um booleano indicando se o valor da opção na regra corresponde ou não ao valor da opção no pacote. Para opções cujos valores são numéricos, alteramos o código fonte para obter a diferença entre os valores da opção na regra e no pacote.
%% \\*
%% Exemplo trecho de código original opção "icode":

%% \begin{figure}[h]
%%   \lstinputlisting[language=C,numbers=none,keywords={}]{original.code}
%%   \caption{Original source code.}
%%   \label{fig:original-code}
%% \end{figure}

%% Trecho modificado:

%% \begin{figure}[h]
%%   \lstinputlisting[language=C,numbers=none,keywords={}]{modified.code}
%%   \caption{Modified source code.}
%%   \label{fig:modified-code}
%% \end{figure}
    
%% }

%% \Fix{Lucas/Guilherme, it would be good to show how this looks like in
%%   code}

%% \subsection{Search}

%% \tname{} is a single-individual hill-climbing like search.
